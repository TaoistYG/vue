# 随笔小记

## Vue(version: 2.6)

项目地址：<https://github.com/vuejs/vue>

### 项目目录

源码目录结构：

- compiler（编译相关），把模板转换成render函数，在render函数中创建虚拟DOM

- core， Vue核心库
  - components【keep-alive.js】
  - global-api【Vue静态方法，vue.filter,vue.extend,vue.mixin,vue.use】
  - Instance【创建vue的实例，定义了Vue的构造函数，初始化，以及生命周期的钩子函数等】
  - observer【定义响应式机制的位置】
  - util【定义公共成员】
  - vodom【定义虚拟DOM】

- platforms， 平台相关代码，web是基于web开发，weex是基于移动端开发

- server: SSR， 服务端渲染

- sfc，将vue文件编译为js对象

- shared，公共代码

### 打包

Rollup打包，只处理js文件

```code
"dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev",
```

-w： 参数是监听源码文件的变化，源码文件变化后自动的重新进行打包

-c： 设置配置文件，scripts/config.js就是配置文件

environment： 环境变量，通过后面设置的值，来打包生成不同版本的Vue

web-full-dev：

- web:指的是打包web平台下的，
- full:表示完整版，包含了编译器与运行时，
- dev:表示的是开发版本，不会对代码进行压缩。

web-runtime-cjs-dev：runtime:表示运行时，cjs：表示CommonJS模块

### Vue版本说明

完整版：包含`编译器`和`运行时`版本

编译器：用来将模板字符串编译成为javascript渲染函数（render函数，render函数用来生成虚拟DOM）的代码，体积大，效率低

运行时：创建Vue实例，渲染并处理虚拟DOM等的代码，体积小，效率高，基本上就是除去编译器的代码。

模块化方式

- UMD，通用的模块版本，支持多种模块方式，可以通过 \<script> 标签直接用在浏览器中
- CommonJS，配合老的打包工具比如 [Browserify]
- ES Module， 2.6 开始 Vue 会提供两个 ES Modules (ESM，也是ES6的模块化方式，这时标准的模块化方式，后期会使用该方式替换其它的模块化方式) 构建文件，一个为打包工具提供，一个为浏览器提供（2.6+）

### 寻找入口文件

npm run dev => 见 scripts/config文件，通过`genConfig`方法获取不同版本的config配置信息

### 入口

#### 模板dom树渲染

npm run dev => src/platform/web/entry-runtime-with-compiler.js

问题：在创建Vue的实例的时候，同时指定了template与render，那么会渲染执行哪个内容？

```code
const vm=new Vue({
  el:'#app',
  template:'<h3>hello template</h3>'
  render(h){
    return h('h4','hello render')
  }
})
```

如果传递了render函数，则不会处理template模板，直接用mount渲染dom

$mount在哪儿调用 => src/core/instance/init.js【查找$mount,下一步寻找Vue._init方法】

Vue._init => src/core/instance/index.js

在Vue这个方法中调用了_init方法，而Vue方法，是在创建Vue实例的时候被调用的。所以上面的Vue方法就是一个构造函数

总结：

- el不能是body 或者是html标签
- 如果没有render，把template转换成render函数。
- 如果有render方法，直接调用mount挂载DOM

### Vue初始化过程

问题：Vue实例成员和Vue的静态成员是从哪里来的？

开始文件【src/platform/web/entry-runtime-with-compiler.js】

关注的点：
1、主要实现方法mount,该方法中一个重要操作就是将`template`模板转换成render函数
2、该文件中并没有创建Vue的实例，实例创建在导入文件中【./runtime/index】

```code
//导入Vue的构造函数
import Vue from "./runtime/index";
```

```code
//保留Vue实例的$mount方法，方便下面重写$mount的功能
const mount = Vue.prototype.$mount;
```

Vue初始化文件【src/platform/web/runtime/index.js】

```code
// install platform runtime directives & components
//通过extend方法注册了与平台相关的全局的指令与组件。
//extend的作用就是将第二个参数的成员全部拷贝到第一个参数中
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
```

问题：注册了哪些指令与组件呢？

```code
import platformDirectives from './directives/index' // v-model, v-show
import platformComponents from './components/index' // v-Transition, v-TransitionGroup
```

全局的指令与组件分别存储到了Vue.options.directives与Vue.options.components中。

例如，我们在项目中使用Vue.component注册的组件，都存储到了Vue.options.components中，也就说存储了Vue.options.components中的组件都是全局可以访问的。

```code
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
```

在Vue的原型中注册了__patch__函数，patch函数的作用就是将虚拟DOM转换成真实的DOM.在给patch函数赋值的时候，首先判断是否为浏览器的环境，如果是则返回patch,否则返回noop,noop是一个空函数

问题：inBrowser是怎样判断是否为浏览器环境的呢？

```code
import { devtools, inBrowser } from "core/util/index";
```

```code
// 文件【core/util/index】
export const inBrowser = typeof window !== 'undefined'
```

初始化Vue中注册`$mount`方法实现，通过`mountComponent`方法实现

```code
import { mountComponent } from "core/instance/lifecycle";
```

总结：Vue与平台相关的实例化代码文件【src/platform/web/runtime/index.js】所做的一些事情

- 注册了`patch`方法
- 注册了`$mount`方法
- 注册了全局的指令和组件

问题：Vue的构造函数在哪？

```code
import Vue from "core/index";
```

文件【core/index】

给Vue构造函数注册一些静态的方法 => `initGlobalAPI(Vue)`【core/global-api/index.js】

文件【import Vue from "./instance/index"】

在该文件中，创建了Vue的构造函数，并且设置了Vue实例的成员。

在创建Vue的实例的时候，这里使用了构造函数，而没有使用类(class)的形式，

原因是：因为使用类来实现构造函数的，下面的方法就不容易实现。在这些方法中为Vue的原型上挂在了很多的成员，而使用类的构造函数不容易实现。

#### 总结

- src/platforms/web/entry-runtime-with-compiler.js
  - web平台相关的入口
  - 重写了平台相关的$mount( )方法，把template模板转换成render函数
  - 注册了Vue.compile( )方法，可以根据传递的HTML字符串返回render函数

- src/platforms/web/runtime/index.js
  - web平台相关
  - 注册和平台相关的全局指令：v-model,v-show
  - 注册和平台相关的全局组件:v-transition,v-transition-group
  - 全局的指令与组件分别存储到了Vue.options.directives与Vue.options.components中。
  - 全局方法
    - `__patch__`：把虚拟DOM转换成真实DOM
​    - `$mount`：挂载方法，把DOM渲染到页面中，在src/platforms/web/entry-runtime-with-compiler.js文件中重写了
    - `$mount`,使其具有了编译的能力。

- src/core/index.js
  - 与平台无关
  - 设置了Vue的静态方法，initGlobalAPI(Vue)

- src/core/instance/index.js
  - 与平台无关
  - 定义了Vue的构造方法，调用了this._init(options)方法（该方法是整个程序的入口）,给Vue中混入了常用的实例成员。

### 静态成员初始化

静态成员完成初始化文件【src/core/index.js】

【initGlobalAPI】

首先初始化了Vue.config对象,并且添加了相应的约束

```code
// 初始化了`Vue.config`对象，该对象是Vue的静态成员
//这里不是定义响应式数据，而是为Vue定义了一个config属性
//并且为其设置了configDef约束。
Object.defineProperty(Vue, "config", configDef);
```

初始化Vue.config对象后，在platforms/web/runtime/index.js为其挂载了成员。

```code
// install platform specific utils
//给Vue.config注册了方法，这些方法都是与平台相关的方法。这些方法是在Vue内部使用的。

Vue.config.mustUseProp = mustUseProp;
//是否为保留的标签，也就是说，传递过来的内容是否为HTML中特有的标签
Vue.config.isReservedTag = isReservedTag;
//是否是保留的属性，也就是说，传递过来的内容是否为HTML中特有的属性
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
```

【讲解(set,delete,observable等内容)】

```code
//初始化了Vue.options对象，并给其扩展了
//components/directives/filters内容

//创建了Vue.options对象，并且没有指定原型。这样性能更高。
Vue.options = Object.create(null);
ASSET_TYPES.forEach((type) => {
    //从`ASSET_TYPES`数组中取出每一项，并为其添加了`s`,来作为Vue.options对象的属性。
    //也就是说给Vue.options中挂载了三个成员，分别是：components/directives/filters，并且都初始化成了空对象。这三个成员的作用是用来存储全局的组件，指令和过滤器，我们通过Vue.component,Vue.directive,Vue.filter创建的组件，指令，过滤器最终都会存储到Vue.options中的这三个成员中。
  Vue.options[type + "s"] = Object.create(null);
});
```

【core/global-api】，_base,extend

```code
//将Vue的构造函数存储到了_base属性中，后期会用到。  
Vue.options._base = Vue;

//设置keep-alive组件
//extend方法的作用是将第二个参数中的属性，拷贝到第一个参数中。下面可以看一下extend方法的具体实现。
extend(Vue.options.components, builtInComponents);
```

extend实现了一个浅拷贝。把一个对象的成员拷贝给另外一个对象

```code
export function extend (to: Object, _from: ?Object): Object {
  for (const key in _from) {
    to[key] = _from[key]
  }
  return to
}
```

将builtInComponents拷贝给Vue.options.components,这里完成的就是全局组件的注册

```code
//设置keep-alive组件
extend(Vue.options.components, builtInComponents);
```

【builtInComponents】=> 导出了KeepAlive这个组件

【initUse(Vue)】 => 注册Vue.use(),用来注册插件【global-api/use.js】

【initMixin()】 => 注册Vue.mixin( )用来实现混入【global-api/mixin.js】

【initExtend()】 => 注册Vue.extend( )，基于传入的options返回一个组件的构造函数【global-api/entend.js】

【initAssetRegisters】 => 注册了Vue.directive(),Vue.component( ),Vue.filter( )

### Vue实例成员初始化

实例成员在`src/core/instance/index.js`文件中

```code
//注册vm的_init( )方法，初始化vm
initMixin(Vue);
//注册vm（Vue实例）的$data/$props/$set/$delete/$watch 属性或方法
stateMixin(Vue);
//初始化事件相关的方法
//$on/$once/$off/$emit
eventsMixin(Vue);
//初始化生命周期相关的混入方法
// $forceUpdate/$destroy
lifecycleMixin(Vue);
//混入render
// $nextTick
renderMixin(Vue);
```

这些方法都是以Mixin进行结尾，表示混入的意思，并且传递的参数都是Vue的构造函数，也就是说这些方法都是为Vue混入一些成员

【initMixin】 => 为Vue实例增加了_init方法，该方法在Vue的构造函数中被调用，该方法也是整个应用的入口

【stateMixin】

【eventsMixin】 => 初始化事件相关方法 `$on/$once/$off/$emit`

- $on:注册事件
- $once：注册事件，只能触发一次
- $off：取消事件
- $emit:是触发事件

【lifecycleMixin】 => 初始化生命周期相关的混入方法`_update/$forceUpdate/$destroy`

【renderMixin】 => 混入render `$nextTick`【installRenderHelpers(Vue.prototype)//安装了渲染有关的帮助方法】

以上这些函数都是在编译的时候会用到，也就是将template模板编译成render函数的时候

#### 补充

在installRenderHelpers 创建了$nextTick

```code
Vue.prototype.$nextTick = function (fn: Function) {
    return nextTick(fn, this)
}
```

_render

```code
 vnode = render.call(vm._renderProxy, vm.$createElement)

 const { render, _parentVnode } = vm.$options
```

render来自于vm.$options,那么就表明这个render是在用户创建Vue的实例的时候执行的的render

render.call范围render方法的调用，第一个参数改变this的指向，第二个参数： vm.$createElement其实就是我们在创建Vue的实例的时候，指定的h函数。h函数的作用就是创建虚拟DOM

### init方法 接上一点中的initMixin

在``src/core/instance/index.js文件中,创建了Vue的构造函数，并且在其内部调用了_init( )方法,而该方法的初始化是在initMixin(Vue);方法中完成的，下面我们再来看一下该方法的实现。_init( )`方法完成了初始化的工作，所以我们重点看一下该方法中初始化了哪些内容

【initMixin】 => src/core/instance/init.js
【initProxy】 => src/core/instance/proxy.js

### initState方法

【initState】：初始化Vue实例中的methods/computed/watch等. => src/core/instance/state.js

【initMethods】 => src/core/instance/state.js

【initData】 => src/core/instance/state.js

【proxy】 => src/core/instance/state.js

### 上述总结

首次渲染时：

1、对Vue进行初始化，同时完成实例成员与静态成员的初始化

2、初始化完成后会执行构造函数，在构造函数中调用了_init方法，该方法是整个Vue的入口，在该方法中调用了vm.$mount方法。

- 第一个$mount【src/platforms/web/entry-runtime-with-compiler.js】=> 把模板编译成render函数，在把模板编译成render函数之前，先判断一下是否传入了render这个选项，如果没有传入，这时就会去获取template选项，如果也没有template这个选项，那么会把el中的内容作为模板，然后把模板编译成render函数【通过compileToFunctions这个函数编译】，把编译好的render函数存储到options.render中
  
- 第二个$mount【src/platforms/web/runtime/index.js】 => 需要重新获取el,（运行时版本，是不会执行src/platforms/web/entry-runtime-with-compiler.js文件中的代码），调用mountComponent( )方法【src/core/instance/lifecycle.js】，在mountComponent( )方法中，首先判断是否有render选项，如果没有但是传入了模板，并且当前是开发环境，那么会打印一个警告信息。警告信息为运行时版本不支持编译器。下面触发了beforeMount这个钩子函数，然后定义updateComponent,在updateComponent中，调用了vm._render( )函数和vm._update函数

3、vm._render()函数的作用就是生成虚拟DOM（在 vm._render()这个方法中，调用了在创建Vue实例的时候传入的render函数,或者是将template编译成的render函数）vm._update( )函数的作用就是将虚拟DOM转换成真实的DOM（在vm._udpate这个方法中调用了vm.__patch__方法将虚拟DOM转换成了真实的DOM然后挂在到页面中）.接下来创建了Watcher的实例，在Watcher实例中调用了updateComponent, 接下来会执行mounted这个钩子函数，完成挂在，最后返回Vue的实例

### 响应式处理入口

问题：

- vm.msg={count:0} 重新给属性赋值，是否是响应式的？
- vm.arr[0]=4 给数组元素赋值，视图是否会更新
- vm.arr.length=0 修改数组的length,视图是否会更新
- vm.arr.push(5) 视图是否会更新

响应式处理分析：

【initState(vm)】=> src/core/instance/init.js，完成了vm状态的初始化，初始化了_data,_props,methods等

【src/core/instance/state.js】

```code
//数据的初始化
if(opts.data){
  initData(vm)//把data中的成员注入到Vue实例，并且转换成响应式的对象
}else{
  //如果options选项中没有data，这里会将data初始化一个空对象。传入到observe这个方法中转换成响应式的对象
  observe(vm._data={},true)//observe就是响应式的入口。
}
```

着重看一下`initSData`方法 => src/core/instance/state.js

```code
observe(data, true /* asRootData */);
```

最后调用了observe方法。data就是传递过来的options选项中的data,第二个参数为true,表示的就是根数据,根数据会做相应的处理。

【observe】 => src/core/observer/index.js

### Observer类 => 核心的作用就是对数组和对象做响应式的处理

Observer.（src/core/observer/index.js）

walk方法实现.（src/core/observer/index.js）

observeArray方法.作用为将数组转换成响应式的

### defineReactive => 将对象中的属性转换成getter和setter

defineReactive

### 依赖收集

在defineReactive方法中定义了getter/setter.在getter中做了收集依赖。依赖收集就是把依赖该属性的watcher对象，添加到dep中的subs数组中。

```code
//下面就是收集依赖
// 判断Dep中是否有target属性，该属性中存储的就是watcher对象
if (Dep.target) {
    //depend方法就是进行依赖收集，就是把watch对象添加到Dep中的subs数组中。
  dep.depend()
  // 如果子对象存在，建立子对象的依赖关系
  if (childOb) {
      //每一个Observer对象，都有一个dep对象，然后调用depend方法建立子对象的依赖关系。
    childOb.dep.depend()
    // 如果属性是数组，则收集数组对象依赖
    if (Array.isArray(value)) {
      dependArray(value)
    }
  }
}
```

什么时候给Dep的target属性赋值的？ => 什么时候创建Watcher对象的？

创建Watcher对象（src/core/instance/lifecycle.js） => mountComponent

Watcher内部，get方法 => 调用pushTarget(this),这里的this就是Watcher对象

pushTarget方法（src/core/observer/dep.js） 

dep.depend() => 收集依赖， Dep.target指的就是Watcher

addDep() => src/core/observer/watcher.js

addSub() => src/core/observer/dep.js

### 数组响应式处理

核心代码在Observer类的构造函数中(/core/observer/index.js)

arrayMethods（src/core/observer/array.js）

对数组中的会修改数组原有内容的方法的处理：

- 先调用数组中的原始方法，例如push,pop等这些方法
- 找到对数组进行新增元素的这些方法，例如:push,unshift,splice
  - ,如果新增了元素，就调用observer中的observerArray这个方法，去遍历数组中的这些新增的元素，然后转换成响应式
  - 当调用了数组中的新增元素的这些方法后，会发送通知。最后返回方法执行的结果。

当浏览器不支持原型属性会调用copyAugment方法，该方法有三个参数，前两个参数与protoAugment方法参数的含义是一样的，第三个参数是arrayKeys【获取数组中的push,pop等方法的名字，arrayKeys是一个数组】.

```code
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)
```

copyAugment

observeArray => 遍历数组中的成员，为数组中的每个对象设置为响应式的对象。

### 数组操作

对数组的push方法，在Vue中做了一定的处理，

- vm.arr.push,通过push方法向数组中添加了一个新的数据后，对应的视图页面也会进行更新。
- vm.arr[0]=100,会修改数组中的内容，但是当数组中的内容修改了以后，视图并没有发生任何的变化，所以这种操作并不是响应式的。也就是说通过数组的索引来修改数组的时候，并没有调用Dep中的notify,也就没有通知watcher去重新渲染视图。（没有监听数组中的每个属性（index,length都是数组的属性）将其转换成响应式，同理vm.arr.length=0也不是响应式的）
- 如何将第二条中的场景设置为响应式呢 => 使用splice方法，vm.arr.splice(0,1,100)，vm.arr.splice(0)

### Watcher

首次渲染的时候的执行过程 | 当数据发生变化后，Watcher的执行过程

- Computed Watcher(计算属性，本质也是通过Watcher来实现的)
- 用户Watcher(侦听器)
- 渲染Watcher

前面两种Watcher是在initState的时候初始化的。

#### 首次渲染的时候的执行过程

mountComponent（/src/core/instance/lifecycle.js）

Watcher类（src/core/observer/watcher.js）

get方法

#### 当数据发生更新的时候，Watcher是怎样工作的

observer/dep.js => 数据发生了变化后，会调用Dep中的notify这个方法

notify => 发布通知

update => 

queueWatcher => src/core/observer/scheduler.js

flushSchedulerQueue

run

总结：当数据发生了变化后，会调用Dep中的notify方法去通知watcher,首先会将watcher放入到一个队列中，然后遍历队列，调用Watcher对象的run方法，在run方法中调用了渲染watcher的updatecomponet这个函数来渲染组件，更新视图，以上就是整个的处理过程。

### 总结响应式处理的过程

响应式是从Vue实例的initState方法开始的

在initState中完成了Vue实例状态的初始化，内部调用了initData方法（把data属性注入到了Vue的实例中，并且在其内部调用了observe方法，在observe方法中把data对象转换成响应式对象）所以说observe就是响应式的入口

observe方法【src/core/observer/index.js】

- 调用observe方法的时候，会传递一个参数value,所以在observe方法中首先会判断一下传递过来的参数value是否为对象，如果不是对象直接返回。
- 然后判断value对象是否有__ob__属性,如果有说明之前已经对其做过响应式的处理，所以直接返回
- 如果没有__ob__属性，在创建observer对象，最后将observer对象返回。

创建observer对象的时候做的事情：

由Observer类创建的（位置:src/core/observer/index.js）在Observer类的构造函数中，给value对象定义不可枚举的__ob__属性，并且通过该数据记录当前的observer对象进行了数组的响应式处理与对象的响应式处理。

数组进行响应式处理：

- 设置了数组常用的方法，例如push,pop等。这些方法会改变原数组，所以当这些方法调用的时候，会发送通知
- 发送通知的时候，找到数组对应的__ob__属性,也就是observer对象，再找到observer对象的dep,然后调用dep中的notify方法
- 更改了这些数组的方法后，下面就开始遍历数组中的每个成员，对每一个成员再去调用observer,如果这个成员是对象，也会将这个对象转换成响应式。

对象的响应式处理：调用的是walk方法

walk方法内部会遍历对象中的所有属性，对每一个属性调用defineReactive方法（位置：src/core/observer/index.js） => 为每一个属性创建dep对象。让dep收集依赖。如果当前对象的属性值是对象，则会调用observe,也就是说如果当前对象的属性是对象，调用observe方法的目录就是把这个对象也转换成响应式对象

在defineReactive方法的内部定义了getter和setter

getter => 收集依赖，当然在收集依赖的时候，会为每一个属性收集依赖。如果属性的值为对象，也要收集依赖。getter方法最终会返回属性的值。
setter => 保存新值，如果新值是对象也会调用observe,把这个新设置的对象也转换为响应式的对象。在setter方法追踪每个。数据发生变化，所以会派发通知，调用dep.notify方法

关于收集依赖的过程：

收集依赖的过程中，首先会调用watcher对象的get方法，在get方法中调用了pushTarget => 将当前的watcher对象记录到Dep.target属性中

在访问data中的成员的时候收集依赖，当访问属性的值时候会触发defineReactive中的getter方法来收集依赖。这时候会把属性对应的watcher对象添加到dep的subs数组中。如果属性的值也是对象，这时会创建一个childOb对象，为子对象收集依赖，目的就是在子对添加或者是删除成员的时候发送通知。

Watcher => 数据发生变化的时候会调用dep.notify方法发送通知，同时在内容调用了update方法，在该方法中又调用了queueWatcher方法，在queueWatcher方法中会判断当前的watcher是否被处理了。如果没有处理，在添加到queue队列中，并调用了flushSchedulerQueue()方法，在该方法中触发了beforeUpdate这个钩子函数，然后调用了watcher.run方法，在该方法中最终调用了updateComponent方法（当前是渲染watcher）.这时已经将数据更新到了视图中，那么我们在页面中看到了最新的数据。最后触发了actived钩子函数和updated钩子函数。

### 动态添加一个响应式属性

通过vm.$set或者是Vue.set来解决

向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi') （注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象）

```code
vm.$set(vm,'abc','a') // error  不能向vue的实例添加属性abc

vm.$set(vm.$data,'abc','12') // error 不能向Vue实例的根数据对象中动态添加属性
```