# 随笔小记

## Vue(version: 2.6)

项目地址：<https://github.com/vuejs/vue>

### 项目目录

源码目录结构：

- compiler（编译相关），把模板转换成render函数，在render函数中创建虚拟DOM

- core， Vue核心库
  - components【keep-alive.js】
  - global-api【Vue静态方法，vue.filter,vue.extend,vue.mixin,vue.use】
  - Instance【创建vue的实例，定义了Vue的构造函数，初始化，以及生命周期的钩子函数等】
  - observer【定义响应式机制的位置】
  - util【定义公共成员】
  - vodom【定义虚拟DOM】

- platforms， 平台相关代码，web是基于web开发，weex是基于移动端开发

- server: SSR， 服务端渲染

- sfc，将vue文件编译为js对象

- shared，公共代码

### 打包

Rollup打包，只处理js文件

```code
"dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev",
```

-w： 参数是监听源码文件的变化，源码文件变化后自动的重新进行打包

-c： 设置配置文件，scripts/config.js就是配置文件

environment： 环境变量，通过后面设置的值，来打包生成不同版本的Vue

web-full-dev：

- web:指的是打包web平台下的，
- full:表示完整版，包含了编译器与运行时，
- dev:表示的是开发版本，不会对代码进行压缩。

web-runtime-cjs-dev：runtime:表示运行时，cjs：表示CommonJS模块

### Vue版本说明

完整版：包含`编译器`和`运行时`版本

编译器：用来将模板字符串编译成为javascript渲染函数（render函数，render函数用来生成虚拟DOM）的代码，体积大，效率低

运行时：创建Vue实例，渲染并处理虚拟DOM等的代码，体积小，效率高，基本上就是除去编译器的代码。

模块化方式

- UMD，通用的模块版本，支持多种模块方式，可以通过 \<script> 标签直接用在浏览器中
- CommonJS，配合老的打包工具比如 [Browserify]
- ES Module， 2.6 开始 Vue 会提供两个 ES Modules (ESM，也是ES6的模块化方式，这时标准的模块化方式，后期会使用该方式替换其它的模块化方式) 构建文件，一个为打包工具提供，一个为浏览器提供（2.6+）

### 寻找入口文件

npm run dev => 见 scripts/config文件，通过`genConfig`方法获取不同版本的config配置信息

### 入口

#### 模板dom树渲染

npm run dev => src/platform/web/entry-runtime-with-compiler.js

问题：在创建Vue的实例的时候，同时指定了template与render，那么会渲染执行哪个内容？

```code
const vm=new Vue({
  el:'#app',
  template:'<h3>hello template</h3>'
  render(h){
    return h('h4','hello render')
  }
})
```

如果传递了render函数，则不会处理template模板，直接用mount渲染dom

$mount在哪儿调用 => src/core/instance/init.js【查找$mount,下一步寻找Vue._init方法】

Vue._init => src/core/instance/index.js

在Vue这个方法中调用了_init方法，而Vue方法，是在创建Vue实例的时候被调用的。所以上面的Vue方法就是一个构造函数

总结：

- el不能是body 或者是html标签
- 如果没有render，把template转换成render函数。
- 如果有render方法，直接调用mount挂载DOM

### Vue初始化过程

问题：Vue实例成员和Vue的静态成员是从哪里来的【src/platforms/web，与web平台相关的文件】

开始文件【src/platform/web/entry-runtime-with-compiler.js】

关注的点：
1、主要实现方法mount,该方法中一个重要操作就是将`template`模板转换成render函数
2、该文件中并没有创建Vue的实例，实例创建在导入文件中【./runtime/index】

```code
//导入Vue的构造函数
import Vue from "./runtime/index";
```

```code
//保留Vue实例的$mount方法，方便下面重写$mount的功能
const mount = Vue.prototype.$mount;
```

Vue初始化文件【src/platform/web/runtime/index.js】

```code
// install platform runtime directives & components
//通过extend方法注册了与平台相关的全局的指令与组件。
//extend的作用就是将第二个参数的成员全部拷贝到第一个参数中
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
```

问题：注册了哪些指令与组件呢？

```code
import platformDirectives from './directives/index' // v-model, v-show
import platformComponents from './components/index' // v-Transition, v-TransitionGroup
```

全局的指令与组件分别存储到了Vue.options.directives与Vue.options.components中。

例如，我们在项目中使用Vue.component注册的组件，都存储到了Vue.options.components中，也就说存储了Vue.options.components中的组件都是全局可以访问的。

```code
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
```

在Vue的原型中注册了__patch__函数，patch函数的作用就是将虚拟DOM转换成真实的DOM.在给patch函数赋值的时候，首先判断是否为浏览器的环境，如果是则返回patch,否则返回noop,noop是一个空函数

问题：inBrowser是怎样判断是否为浏览器环境的呢？

```code
import { devtools, inBrowser } from "core/util/index";
```

```code
// 文件【core/util/index】
export const inBrowser = typeof window !== 'undefined'
```

初始化Vue中注册`$mount`方法实现，通过`mountComponent`方法实现

```code
import { mountComponent } from "core/instance/lifecycle";
```

总结：Vue与平台相关的实例化代码文件【src/platform/web/runtime/index.js】所做的一些事情

- 注册了`patch`方法
- 注册了`$mount`方法
- 注册了全局的指令和组件

问题：Vue的构造函数在哪？

```code
import Vue from "core/index";
```

文件【core/index】

给Vue构造函数注册一些静态的方法 => `initGlobalAPI(Vue)`【core/global-api/index.js】